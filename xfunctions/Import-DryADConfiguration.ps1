using Namespace System.IO
using Namespace System.Management.Automation
using Namespace System.Collections.Generic
<#  
    This is an AD Config module for use with DryDeploy, or by itself.
    Copyright (C) 2021  Bjørn Henrik Formo (bjornhenrikformo@gmail.com)
    LICENSE: https://raw.githubusercontent.com/bjoernf73/dry.module.ad/main/LICENSE

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#>
function Import-DryADConfiguration {
    [CmdLetBinding(DefaultParameterSetName = 'Local')]
    param (
        [Parameter(HelpMessage="Variables are used for replacements in configs and GPOs. You may pass in an 
        array of objects, each containing a 'name' and 'value' property. You may omit this, and use the 
        VariablesPath parameter instead. ")]
        [List[PSObject]] 
        $Variables,

        [Parameter(HelpMessage = "Path to a json containing an array of objects resolving replacement patterns in your configuration. The objects must contain the properties 'name' and 'value'")]
        [ValidateScript({Resolve-Path -Path $_ })]
        [FileInfo]$VariablesPath,

        [Parameter(Mandatory, HelpMessage="Path of the configuration directory. You may split the configuration 
        into multiple files, as long as they're all in this directory.")]
        [ValidateScript({Resolve-Path -Path $_})]
        [directoryinfo]$ConfigurationPath,

        [Parameter(HelpMessage = "Shortname (not IP!) of the computer for which the configuration is run")]
        [string]$ComputerName,

        [Parameter(HelpMessage = "Active Directory site name for which the configuration is done")]
        [string]$ADSite,

        [Parameter(HelpMessage = "Array of one or more Types to process. By default, all are processed")]
        [ValidateSet('ou_schema', 'groups', 'group_members', 'rights', 'gpo_imports', 'gpo_links',
        'wmi_filters', 'wmi_filters_links', 'ad_schema', 'netlogon', 'adm_templates', 'users', 'users_memberof')] 
        [string[]]$Types,

        [Parameter(Mandatory, ParameterSetName = 'Local', HelpMessage = "Specify a resolvable name or IP to a Domain Controller to perform AD actions on")]
        [string]$DomainController,

        [Parameter(Mandatory, ParameterSetName = 'Remote')]
        [pssession]$PSSession,

        [Parameter(HelpMessage = "Should only be `$true when called from DryDeploy. Will allow autogenerated 
        passwords for users that are created to be stored in DryDeploy's Credentials store. If you're running
        standalone (not as part of DryDeploy, hence `$DryDeploy = `$false), then passwords of users that are 
        configured with the property .password.get_or_generate = 'generate', are autogenerated, but lost. You 
        will have to reset the passwords of the created users to access those accounts. Use instead
        .password.get_or_generate = 'get' to be prompted for the credentials.")]
        [Switch]$DryDeploy
    )
    try {
        ol i 'Import-DryADConfiguration started' -sh
        
        if ($DebugPreference) { 
            if ($DebugPreference -eq 'Inquire') {
                $DebugPreference = 'Continue'
            }
        }

        [string]$ExecutionType = $PSCmdlet.ParameterSetName
        ol i 'Execution Type', "$ExecutionType"

        $ConfigurationPath = (Resolve-Path -Path $ConfigurationPath -ErrorAction Stop).Path
        ol i 'ConfigurationPath', "$ConfigurationPath"

        if ($VariablesPath) {
            $VariablesPath = (Resolve-Path -Path $VariablesPath -ErrorAction Stop).Path
            ol i 'VariablesPath', "$VariablesPath"
        }
        
        if ($ExecutionType -eq 'Remote') {
            $ConfigurationPublicCertificatePath = Join-Path -Path $ConfigurationPath -ChildPath "RemoteSystemPublicCertificate.cer"
            $DomainDN = Get-DryADServiceProperty -Service 'domain' -Property 'DistinguishedName' -PSSession $PSSession
            $DomainFQDN = Get-DryADServiceProperty -Service 'domain' -Property 'DNSRoot' -PSSession $PSSession
            $DomainNB = Get-DryADServiceProperty -Service 'domain' -Property 'NetBIOSName' -PSSession $PSSession
            $ConfigurationNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'configurationNamingContext' -PSSession $PSSession
            $SchemaNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'schemaNamingContext' -PSSession $PSSession
            $SchemaMaster = Get-DryADServiceProperty -Service 'forest' -Property 'SchemaMaster' -PSSession $PSSession
        }
        else {
            $DomainDN = Get-DryADServiceProperty -Service 'domain' -Property 'DistinguishedName' -DomainController $DomainController
            $DomainFQDN = Get-DryADServiceProperty -Service 'domain' -Property 'DNSRoot' -DomainController $DomainController
            $DomainNB = Get-DryADServiceProperty -Service 'domain' -Property 'NetBIOSName' -DomainController $DomainController
            $ConfigurationNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'configurationNamingContext' -DomainController $DomainController
            $SchemaNC = Get-DryADServiceProperty -Service 'rootdse' -Property 'schemaNamingContext' -DomainController $DomainController
            $SchemaMaster = Get-DryADServiceProperty -Service 'forest' -Property 'SchemaMaster' -DomainController $DomainController
        }

        $SourceGPOsPath = Join-Path -Path $ConfigurationPath -ChildPath "gpo_imports"
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   VARIABLES
        #    
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($VariablesPath) {
            if ($Variables) {
                ol w "You should not pass both `$Variables and `VariablesPath - select one"
                throw "You should not pass both `$Variables and `VariablesPath - select one"
            }
            $Variables = Get-DryADJson -File $VariablesPath
        }

        $DefaultVariables = @('DomainDN', 'DomainFQDN', 'DomainNB', 'ConfigurationNC', 'SchemaNC')
        if ($ADSite) { $DefaultVariables += 'ADSite' }
        if ($ComputerName) { $DefaultVariables += 'ComputerName' }
        
        $DefaultVariables.foreach({
            $CurrentDefaultVariable = $_
            if ($null -eq ($Variables | Where-Object { $_.Name -eq $CurrentDefaultVariable })) {
                $Variables += New-Object -TypeName PSObject -Property @{
                    Name  = "$CurrentDefaultVariable"
                    Value = Get-Variable -Name $CurrentDefaultVariable -Value
                }
            }
        })
        
        # For debug
        $Variables.foreach({
            param ($x)
            ol i @("Var: $($x.name)","$($x.Value)")
        })

        ol i 'Domain FQDN', "$DomainFQDN"
        ol i 'Domain NB', "$DomainNB"
        if ($ADSite) {
            ol i 'ADSite', "$ADSite"
        }
        elseif ($null -ne ($Variables | Where-Object { $_.Name -eq 'ADSite' })) {
            [string]$ADSite = ($Variables | Where-Object { $_.Name -eq 'ADSite' }).Value
            ol i 'ADSite', "$ADSite"
        }
        
        if ($ComputerName) {
            ol i 'ComputerName', "$ComputerName"
        }
        elseif ($null -ne ($Variables | Where-Object { $_.Name -eq 'ComputerName' })) {
            [string]$ComputerName = ($Variables | Where-Object { $_.Name -eq 'ComputerName' }).Value
            ol i 'ComputerName', "$ComputerName"
        }
        ol i ' ' -h
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   REPLACEMENT HASH
        #   Only used for json-formatted GPOs
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        $ReplacementHash = @{}
        foreach ($Var in $Variables) {
            $ReplacementHash.Add("###$($Var.Name)###", $Var.Value)
        }
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ROLE CONFIGURATION OBJECT
        #   Pick up all jsons (*.json) in $ConfigurationPath, and merge
        #   into $RoleConfiguration
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        Remove-Variable -Name RoleConfiguration, ADConfObject, ConfigurationPathFiles -ErrorAction Ignore
        $RoleConfiguration = New-Object -TypeName PSObject
        $ConfigurationPathFiles = @(Get-ChildItem -Path "$ConfigurationPath\*" -Include "*.jsonc", "*.json" -ErrorAction Stop)
        
        foreach ($ADConfFile in $ConfigurationPathFiles) {
            $ADConfObject = Get-DryADJson -Path $ADConfFile.FullName -ErrorAction Stop
            $RoleConfiguration = (Merge-DryADPSObjects -FirstObject $RoleConfiguration -SecondObject $ADConfObject)
        }
 
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   CASING
        #   Variables that specifies case modification of OUs, GPOs, groups and users.
        #   Valid values are 'upper', lower', 'capitalized' and 'ignore'. Defaults
        #   to ignore
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        [string]$OUCase    = 'ignore'
        [string]$GPOCase   = 'ignore'
        [string]$GroupCase = 'ignore'
        [string]$UserCase  = 'ignore'

        if ($RoleConfiguration.casing.ad_organizational_unit_case) {
            [string]$OUCase = $RoleConfiguration.casing.ad_organizational_unit_case
        }
        if ($RoleConfiguration.casing.ad_gpo_case) {
            [string]$GPOCase = $RoleConfiguration.casing.ad_gpo_case
        }
        if ($RoleConfiguration.casing.ad_group_case) { 
            [string]$GroupCase = $RoleConfiguration.casing.ad_group_case
        }
        if ($RoleConfiguration.casing.ad_user_case) { 
            [string]$UserCase = $RoleConfiguration.casing.ad_user_case
        }

        ol v 'Casing - OUs',    "$OUCase"
        ol v 'Casing - GPOs',   "$GPOCase"
        ol v 'Casing - Groups', "$GroupCase"
        ol v 'Casing - Users',  "$UserCase"

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   PROGRESS COUNTERS
        #   Counts configurations to process before start, to show
        #   a progress bar during configuration
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        [int]$ElementsCounter = 0
        [int]$NumberOfElementsToProcess = 0

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   AD SCHEMA
        #   Action: Get and Count 
        #   Dataset: $RoleConfiguration
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (Test-Path -Path "$ConfigurationPath\ad_schema" -ErrorAction Ignore) {
            if (($Types -icontains 'ad_schema') -or ($null -eq $Types)){ 
                $ProcessADSchema = $true
                $ADSchemaExtensions = @(Get-ChildItem -Path "$ConfigurationPath\ad_schema\*" -Include "*.ldf")
                $NumberOfElementsToProcess += $ADSchemaExtensions.Count
            } 
            $NumberOfADSchemaExtensions = $ADSchemaExtensions.Count
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   NETLOGON
        #   Action: Count 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (Test-Path -Path "$ConfigurationPath\netlogon" -ErrorAction Ignore) {  
            if (($Types -icontains 'netlogon') -or 
                ($null -eq $Types)) {

                $ProcessNETLOGON = $true
                $NumberOfElementsToProcess++
                $NumberOfNETLOGONs = 1
            } 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   adm_templates
        #   Action: Count 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (Test-Path -Path "$ConfigurationPath\adm_templates" -ErrorAction Ignore) {  
            if (($Types -icontains 'adm_templates') -or ($null -eq $Types)) { 
                $ProcessAdmTemplates = $true
                $NumberOfElementsToProcess++
            } 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS
        #   Action: Get, Count and String Replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($RoleConfiguration.ou_schema) {
            [array]$DomainOUs = @($RoleConfiguration.ou_schema)
            if (($Types -icontains 'ou_schema') -or ($null -eq $Types)) { 
                $ProcessOUs = $true 
                $NumberOfElementsToProcess += $DomainOUs.Count
            }
        }

        # Replace all replacement patterns 
        if ($DomainOUs) {
            $DomainOUs = Resolve-DryADReplacementPatterns -inputobject $DomainOUs -Variables $Variables
        }
        $NumberOfOUs = $DomainOUs.Count

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Resolve .path from .parent_alias and .child_path
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        
        $AnOUWasResolved = $true
        do {
            $AnOUWasResolved = $false 
            # Loop through DomainOUs that already have a path
            foreach ($ResolvedOU in $DomainOUs | Where-Object { $null -ne $_.path }) {
                
                # Loop through DomainOUs that do not have a path
                foreach ($UnresolvedOU in $DomainOUs | Where-Object { $null -eq $_.path }) {
                    try {
                        if ($UnresolvedOU.parent_alias -eq $ResolvedOU.alias) {
                            $Path = ($ResolvedOU.path + '/' + $UnresolvedOU.child_path) -replace '//', '/'
                            $AnOUWasResolved = $true #keeps the loop going
                            
                            # Add Path property and remove parent_alias and child_path
                            $UnresolvedOU | Add-Member -MemberType NoteProperty -Name 'Path' -Value $Path -Force
                            $UnresolvedOU.PSObject.Properties.Remove('parent_alias')
                            $UnresolvedOU.PSObject.Properties.Remove('child_path')
                        }
                    }
                    catch {
                        $PSCmdLet.ThrowTerminatingError($_)
                    }
                    finally {
                        $Path = $null
                    }
                }
            }
        }
        While ($AnOUWasResolved)

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Display resolved paths
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($DomainOUs.count -gt 0) {
            ol i "Resolved OU Aliases" -sh 
            foreach ($OU in $DomainOUs) {
                ol i "$($OU.Alias)", "$($OU.Path)"
                if($null -eq $OU.Path) {
                    ol e "Unable to resolve OU for '$($OU.Alias)'"
                    throw "Unable to resolve OU for '$($OU.Alias)'"
                }
            }
        }
    
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS PATHS
        #   Action: Convert To 'distinguishedName' 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        foreach ($OU in $DomainOUs) {
            $OU.Path = ConvertTo-DryADDistinguishedName -Name $OU.Path -Case $OUcase
            ol d "Domain OU dN for $($OU.Alias) is: '$($OU.Path)'" 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   WMI Filter Imports and Links
        #   Action: Get, Count and String Replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'wmi_filters') -or 
            ($Types -icontains 'wmi_filters_links') -or 
            ($null -eq $Types)){ 
            if ($RoleConfiguration.wmi_filters) {
                [array]$DomainWMIFilters += @($RoleConfiguration.wmi_filters)
                $DomainWMIFilters = Resolve-DryADReplacementPatterns -inputobject $DomainWMIFilters -Variables $Variables

                # Count the wmi_filters, but only if we're actually importing them
                if (($Types -icontains 'wmi_filters') -or ($null -eq $Types)){
                    $ProcessWMIFilterImports = $true
                    $NumberOfElementsToProcess += $DomainWMIFilters.Count
                    $NumberOfWMIFilters = $DomainWMIFilters.Count
                }

                if (($Types -icontains 'wmi_filters_links') -or ($null -eq $Types)){
                    $ProcessWMIFilterLinks = $true
                    $DomainWmiFilterLinksCount = 0
                    $DomainWMIFilters.foreach({
                            $_.links.foreach({
                                    $DomainWmiFilterLinksCount++
                                })
                        })
                    $NumberOfWMIFilterLinks = $DomainWmiFilterLinksCount
                    $NumberOfElementsToProcess += $NumberOfWMIFilterLinks
                }
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   RIGHTS GROUPS
        #   Action: Get, Count, String Replacement, Resolve Paths and Convert Case
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($RoleConfiguration.rights_groups) {
            $DomainRightsGroups = @($RoleConfiguration.rights_groups)
            if (($Types -icontains 'rights_groups') -or ($null -eq $Types)) { 
                $ProcessRightsGroups = $true
                $NumberOfElementsToProcess += $DomainRightsGroups.Count
                $NumberOfRightsGroups = $DomainRightsGroups.Count
            }
            # Replace regardless of $Types -icontains 'rights_groups', since RightsGroups are referenced by Rights, GroupMembers and GPOImports
            $DomainRightsGroups = Resolve-DryADReplacementPatterns -inputobject $DomainRightsGroups -Variables $Variables

            # Resolve OU from schema
            foreach ($RightsGroup in $DomainRightsGroups) {
                if ($null -eq $RightsGroup.path) {
                    $Path = Get-DryADOUPathFromAlias -Alias $RightsGroup.Alias -OUs $DomainOUs
                    $RightsGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase 
                $RightsGroup.groupname = ConvertTo-DryADCase -Name $RightsGroup.groupname -Case $Groupcase
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ROLE GROUPS
        #   Action: Count and String replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($RoleConfiguration.role_groups) {
            $DomainRoleGroups = @($RoleConfiguration.role_groups)
            if (($Types -icontains 'role_groups') -or ($null -eq $Types)){ 
                $ProcessRoleGroups = $true
                $NumberOfElementsToProcess += $DomainRoleGroups.Count
                $NumberOfRoleGroups = $DomainRoleGroups.Count
            }
            # Replace regardless of $Types -icontains 'rights_groups', since groups are referenced by -component GroupMembers
            $DomainRoleGroups = @(Resolve-DryADReplacementPatterns -inputobject $DomainRoleGroups -Variables $Variables)

            # Resolve domain OU paths from schema
            foreach ($RoleGroup in $DomainRoleGroups) {
                if ($null -eq $RoleGroup.path) {
                    $Path = Get-DryADOUPathFromAlias -Alias $RoleGroup.Alias -OUs $DomainOUs
                    $RoleGroup | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                }
                # Convert to $GroupCase 
                $RoleGroup.groupname = ConvertTo-DryADCase -Name $RoleGroup.groupname -Case $Groupcase
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP MEMBERS
        #   Action: Count
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        $NumberOfDomainMemberAndMemberOf = 0
       
        if (($Types -icontains 'group_members') -or ($null -eq $Types)){ 
            $ProcessGroupMembers = $true

            # Both Role and Rights groups may have .member and .memberof 
            foreach ($DomainRoleGroup in $DomainRoleGroups) {
                $NumberOfDomainMemberAndMemberOf += $DomainRoleGroup.Member.Count
                $NumberOfDomainMemberAndMemberOf += $DomainRoleGroup.MemberOf.Count
            }

            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                $NumberOfDomainMemberAndMemberOf += $DomainRightsGroup.Member.Count
                $NumberOfDomainMemberAndMemberOf += $DomainRightsGroup.MemberOf.Count
            }
            $NumberOfElementsToProcess += $NumberOfDomainMemberAndMemberOf
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   RIGHTS
        #   Action: Count and Resolve Paths
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'rights') -or ($null -eq $Types)) { 
            $ProcessRights = $true
            $NumberOfDomainRights = 0

            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                foreach ($DomainRight in $DomainRightsGroup.Rights) {
                    $NumberOfElementsToProcess++
                    # Update the debug counter as well
                    $NumberOfDomainRights++
                    # Resolve Path
                    if ($null -eq $DomainRight.Path) {
                        $Path = Get-DryADOUPathFromAlias -Alias $DomainRight.Alias -OUs $DomainOUs
                        $DomainRight | Add-Member -MemberType NoteProperty -Name Path -Value $Path

                        # Once resolved, remove Alias. 
                        $DomainRight.PSObject.Properties.Remove('Alias')
                    }
                }
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICY IMPORTS
        #   Action: Count and String replacement
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'gpo_imports') -or ($null -eq $Types)){  
            if ($RoleConfiguration.gpo_imports){   
                $ProcessGPOImports = $true   
                $DomainGPOImports = @($RoleConfiguration.gpo_imports)
                
                # If the configuration set contains json-gpos... 
                $JsonGPOImports = @($RoleConfiguration.gpo_imports | Where-Object {$_.type -eq 'json'})
                $RequiresGPOHelper = $false
                if ($JsonGPOImports.count -gt 0) {
                    $RequiresGPOHelper = $true
                }
 
                $NumberOfElementsToProcess += $DomainGPOImports.Count
                $NumberOfGPOImports += $DomainGPOImports.Count 
                $DomainGPOImports = Resolve-DryADReplacementPatterns -inputobject $DomainGPOImports -Variables $Variables
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICY LINKS
        #   Action: Count, String replacement and Resolve paths from aliases
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'gpo_links') -or ($null -eq $Types)){  
            if ($RoleConfiguration.gpo_links) {  

                $ProcessGPOLinks = $true
                $DomainGPOLinks = @($RoleConfiguration.gpo_links)
                $NumberOfElementsToProcess += $DomainGPOLinks.Count
                $NumberOfGPOLinks = $DomainGPOLinks.Count

                # String Replacements
                $DomainGPOLinks = Resolve-DryADReplacementPatterns -inputobject $DomainGPOLinks -Variables $Variables
                
                # Resolve Domain Paths from OU schema
                foreach ($DomainGPOLink in $DomainGPOLinks) {
                    if ($null -eq $DomainGPOLink.path) {
                        $Path = Get-DryADOUPathFromAlias -Alias $DomainGPOLink.Alias -OUs $DomainOUs
                        $DomainGPOLink | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                }
            } 
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USERS
        #   Action: Count, String replacement, resolve OUs
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'users') -or ($null -eq $Types)){  
            if ($RoleConfiguration.users) {
                
                $DomainUsers = @($RoleConfiguration.users)
                if (($Types -icontains 'users') -or ($null -eq $Types)){ 
                    $ProcessUsers = $true
                    $NumberOfElementsToProcess += $DomainUsers.Count
                    $NumberOfUsers = $DomainUsers.Count
                }

                # Replace any replacement pattern 
                if ($DomainUsers.count -gt 0) {
                    $DomainUsers = @(Resolve-DryADReplacementPatterns -inputobject $DomainUsers -Variables $Variables)
                }

                # Resolve domain OU paths from schema
                foreach ($User in $DomainUsers) {
                    if ($null -eq $User.path) {
                        # Resolve domain paths from OU schema
                        $Path = Get-DryADOUPathFromAlias -Alias $User.Alias -OUs $DomainOUs
                        $User | Add-Member -MemberType NoteProperty -Name Path -Value $Path
                    }
                    # Convert to $GroupCase
                    $User.name = ConvertTo-DryADCase -Name $User.name -Case $UserCase
                }
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USER'S GROUP MEMBERSHIPS
        #   Action: Count
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if (($Types -icontains 'users_memberof') -or ($null -eq $types)) {  
            
            $ProcessUserMemberOf = $true
            # Count User's MemberOfs
            $NumberOfDomainUserMemberOf = 0
            foreach ($DomainUser in $DomainUsers) {
                $NumberOfDomainUserMemberOf += $DomainUser.MemberOf.Count
            }
            $NumberOfElementsToProcess += $NumberOfDomainUserMemberOf
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   AD DRIVE
        #   Action: Make sure the AD Drive on the executing system is created when 
        #   importing the ActiveDirectory module, and that it points to the correct
        #   Domain Controller.  
        #   - If Remote execution, we remote into a Domain Controller, and the AD 
        #     drive should be pointed to localhost. 
        #   - If Local execution, the AD Drive should point to $DomainController
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        switch ($ExecutionType) {
            'Remote' {
                ol i "Configuring AD Drive on $($PSSession.ComputerName)" -sh
                Set-DryADDrive -PSSession $PSSession
            }
            'Local' {
                ol i "Configuring AD Drive on local system" -sh
                Set-DryADDrive -DomainController $DomainController
            }
        }
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   AD WEB SERVICES ON DOMAIN CONTROLLER
        #   Action: Test, and wait for the service to become available
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ExecutionType -eq 'Remote') {
            ol i "Testing and Waiting for AD Availability" -sh
            Wait-DryADForADWebServices -DomainDN $DomainDN -PSSession $PSSession
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   SCHEMA UPDATES 
        #   Action: Invoke/Update. Will only work when 'Remote' and $DomainController 
        #   is the Schema Master
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessADSchema) {

            ol i "AD Schema Extensions ($($ADSchemaExtensions.count))" -sh
            foreach ($ADSchemaExtension in $ADSchemaExtensions) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Schema extension: $($ADSchemaExtension.BaseName)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $ADSchemaExtJson = Get-Content -Path (Join-Path -Path (Split-Path -Path $ADSchemaExtension.FullName) -ChildPath "$($ADSchemaExtension.BaseName).json") |
                    ConvertFrom-Json -ErrorAction 'Stop'

                $ADSchemaExtContent = Get-Content -Path $ADSchemaExtension.FullName -Raw -ErrorAction 'Stop'

                $ExtendDryADSchemaParams = @{
                    Type         = $ADSchemaExtension.BaseName
                    SuccessCount = $ADSchemaExtJson.success_string_match_count
                    Content      = $ADSchemaExtContent
                    Variables    = $Variables
                    SchemaMaster = $SchemaMaster 
                }
                if ($ExecutionType -eq 'Remote') {
                    $ExtendDryADSchemaParams += @{
                        PSSession = $PSSession
                    }
                }
                
                ol i 'Extending AD Schema, type', "$($ADSchemaExtension.BaseName)"
                Set-DryADSchemaExtension @ExtendDryADSchemaParams
            }

            $DebugCounter = $NumberOfADSchemaExtensions
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessSchema)

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   NETLOGON
        #   Action: Configure 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessNETLOGON) {  
            ol i "NETLOGON File Copy" -sh
            # increment the element counter and update progress
            $ElementsCounter++
            $WriteProgressParameters = @{
                Activity        = 'Configuring Active Directory'
                Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): NETLOGON"
                PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
            }
            Write-Progress @WriteProgressParameters
            $NETLOGONSourcePath = Join-Path -Path $ConfigurationPath -ChildPath 'netlogon'
            switch ($ExecutionType) {
                'Local' {
                    $NETLOGONTargetPath = "\\$DomainFQDN\NETLOGON\"
                }
                'Remote' {
                    $NETLOGONTargetPath = "C:\Windows\SYSVOL\domain\scripts\"
                }
            }
            ol i "NETLOGON source path", "$NETLOGONSourcePath\*"
            ol i "NETLOGON target path", "$NETLOGONTargetPath"

            $CopyNETLOGONParams = @{
                Path        = "$NETLOGONSourcePath\*"
                Destination = "$NETLOGONTargetPath" 
                Recurse     = $true 
                Force       = $true
                ErrorAction = 'Stop'
            }
            if ($ExecutionType -eq 'Remote') {
                $CopyNETLOGONParams += @{
                    ToSession = $PSSession        
                }
            }
            
            Copy-Item @CopyNETLOGONParams
        
            $DebugCounter += $NumberOfNETLOGONs
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   adm_templates
        #   Action: Configure 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessAdmTemplates) {  
            ol i "adm_templates File Copy" -sh
            # increment the element counter and update progress
            $ElementsCounter++
            $WriteProgressParameters = @{
                Activity        = 'Configuring Active Directory'
                Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Administrative Templates"
                PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
            }
            Write-Progress @WriteProgressParameters
            
            $AdmTemplatesSourcePath = "$ConfigurationPath\adm_templates\*"
            switch ($ExecutionType) { 
                'Local' {
                    $AdmTemplatesTargetPath = "\\\\$DomainFQDN\\SYSVOL\\$DomainFQDN\\Policies\\PolicyDefinitions\\"
                }
                'Remote' {
                    $AdmTemplatesTargetPath = "C:\\Windows\\SYSVOL\\domain\\Policies\\PolicyDefinitions\\"
                }
            }

            ol i "adm_templates source path", $AdmTemplatesSourcePath
            ol i "adm_templates target path", $AdmTemplatesTargetPath

            $CopyDryFilesToRemoteTargetParams = @{
                SourcePath = "$AdmTemplatesSourcePath" 
                TargetPath = "$AdmTemplatesTargetPath" 
            }
            
            if ($PSSession) {
                $CopyDryFilesToRemoteTargetParams += @{
                    PSSession = $PSSession
                }   
            }
            Copy-DryADFilesToRemoteTarget @CopyDryFilesToRemoteTargetParams | 
                Out-Null
        
            $DebugCounter += 1
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ORGANIZATIONAL UNITS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessOUs) {

            ol i "OUs ($($DomainOUs.count))" -sh
            foreach ($OU in $DomainOUs) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Creating OU: $($OU.Path)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
    
                # Create instance of class OU and invoke method CreateOU()
                ol i "Creating OU", "$($OU.path)"
                
                switch ($ExecutionType) {
                    'Local' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $DomainController)
                    }
                    'Remote' {
                        [OU]$OUObject = [OU]::new("$($OU.path)", "$DomainFQDN", $PSSession)
                    }
                }
                $OUObject.CreateOU()
                
                Remove-Variable -Name OUObject -ErrorAction Ignore            
            }

            $DebugCounter += $NumberOfOUs
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }

        } # if ($ProcessOU)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   WMI FILTERS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessWMIFilterImports) {
            # WMIfilters. Log some info, then loop through each
            ol i "WMIFilters ($($DomainWMIfilters.count))" -sh

            # Make sure 'Allow System Only Change' in registry on domain controller is 1
            # If it isn't, WMIFilter creation will fail with access denied
            ol d "Calling 'Set-DryADRemoteRegistry' to set 'Allow System Only Change' to 1"
            
            $AllowSystemOnlyChangeParameters = @{
                BaseKey     = 'HKEY_LOCAL_MACHINE' 
                LeafKey     = 'System\\CurrentControlSet\\Services\\NTDS\\Parameters' 
                ValueName   = 'Allow System Only Change' 
                ValueData   = 1 
                ValueType   = 'DWORD'
                PSSession   = $PSSession
                ErrorAction = 'Stop'
            }
            
            Set-DryADRemoteRegistry @AllowSystemOnlyChangeParameters
            
            # $DomainWMIfilters
            foreach ($GPOWMIFilter in $DomainWMIfilters) {
                
                # Progress
                $ElementsCounter++  
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing WMIFilter '$($GPOWMIFilter.Name)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                }
                Write-Progress @WriteProgressParameters
            
                # Any GPMC command must run in a remote session, since the cmdlets lack the -credentials parameter
                $NewDryWmiFilterParameters = @{
                    Name        = $GPOWMIFilter.Name 
                    Description = $GPOWMIFilter.Description 
                    Query       = [array]$GPOWMIFilter.Queries 
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryWmiFilterParameters += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryWmiFilterParameters += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Importing WMI Filter", "$($GPOWMIFilter.Name)"
                New-DryADWmiFilter @NewDryWmiFilterParameters
            }


            $DebugCounter += $NumberOfWMIFilters
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   RIGHTS GROUPS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessRightsGroups) {
            ol i "Rights Groups ($($DomainRightsGroups.count))" -sh
 
            # loop through domain Rights
            foreach ($RightsGroup in $DomainRightsGroups) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Rights Group: $($RightsGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   

                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RightsGroup.groupname
                    Path        = $RightsGroup.path
                    Description = $RightsGroup.groupdescription
                    Type        = $RightsGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Rights Group", "$($RightsGroup.groupname)" 
                New-DryADSecurityGroup @NewDryADSecurityGroupParams
            }

            $DebugCounter += $NumberOfRightsGroups
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessRightsGroups)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ROLE GROUPS 
        #   Action: Create
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessRoleGroups) {
            ol i "Role Groups ($($DomainRoleGroups.count))" -sh
 
            foreach ($RoleGroup in $DomainRoleGroups) {
                
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Role Group: $($RoleGroup.groupname)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   

                }
                Write-Progress @WriteProgressParameters

                $NewDryADSecurityGroupParams = @{
                    Name        = $RoleGroup.groupname
                    Path        = $RoleGroup.path
                    Description = $RoleGroup.groupdescription
                    Type        = $RoleGroup.grouptype
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADSecurityGroupParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADSecurityGroupParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "Creating Role Group", "$($RoleGroup.groupname)" 
                New-DryADSecurityGroup @NewDryADSecurityGroupParams
            }

            $DebugCounter += $NumberOfRoleGroups
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
                 
        } # if ($ProcessRoleGroups)

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP'S GROUP MEMBERS 
        #   Action: Add Role Groups to RightsGroups
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessGroupMembers) {
            ol i "Group Members - ($NumberOfDomainMemberAndMemberOf)" -sh
            
            # Both Role and Rights groups may have .member and .memberof 
            foreach ($DomainRoleGroup in $DomainRoleGroups) {
                foreach ($DomainRoleGroupMember in $DomainRoleGroup.Member) {
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($DomainRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add Members to $DomainRoleGroup
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRoleGroup.groupname
                        Member = $DomainRoleGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members", "Adding '$DomainRoleGroupMember' to '$($DomainRoleGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($DomainRoleGroupMemberOf in $DomainRoleGroup.MemberOf) {
                    
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($DomainRoleGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $DomainRoleGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRoleGroupMemberOf
                        Member = $DomainRoleGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members", "Adding '$($DomainRoleGroup.groupname)' to '$DomainRoleGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }


            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                foreach ($DomainRightsGroupMember in $DomainRightsGroup.Member) {
                    # increment the element counter and update progress
                    
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member: $($DomainRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRightsGroup.groupname
                        Member = $DomainRightsGroupMember
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members", "Adding '$DomainRightsGroupMember' to '$($DomainRightsGroup.groupname)'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
                foreach ($DomainRightsGroupMemberOf in $DomainRightsGroup.MemberOf) {
                    # increment the element counter and update progress
                    
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Group Member Of: $($DomainRightsGroup.groupname)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters

                    # Add $DomainRightsGroup to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainRightsGroupMemberOf
                        Member = $DomainRightsGroup.groupname
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members", "Adding '$($DomainRightsGroup.groupname)' to '$DomainRightsGroupMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }

            $DebugCounter += $NumberOfDomainMemberAndMemberOf
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USERS 
        #   Action: Getting the connection point's public certificate. 
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessUsers) {
            if (($NumberOfUsers.Count -gt 0) -and ($ExecutionType -eq 'Remote')){
                ol i "Users - Getting the Connection Point's public certificate" -sh
                try {
                    Get-DryADRemotePublicCertificate -PSSession $PSSession -CertificateFile $ConfigurationPublicCertificatePath
                }
                catch {
                    $PSCmdLet.ThrowTerminatingError($_)
                }
            }

            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            # 
            #   USERS 
            #   Action: Create
            #
            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            ol i "Users ($($DomainUsers.count))" -sh

            foreach ($User in $DomainUsers) {

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): User: $($User.name)"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   

                }
                Write-Progress @WriteProgressParameters

                $NewDryADUserParams = @{
                    User      = $User
                    DomainNB  = $DomainNB
                    DryDeploy = $DryDeploy
                }
                switch ($ExecutionType) {
                    'Local' {
                        $NewDryADUserParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $NewDryADUserParams += @{
                            PSSession                   = $PSSession
                            DCPublicCertificateFilePath = $ConfigurationPublicCertificatePath
                        }
                    }
                }
                ol i "Creating User", "$($User.name)" 
                New-DryADUser @NewDryADUserParams
            }

            $DebugCounter += $NumberOfUsers
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessUsers)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   USER'S GROUP MEMBERSHIPS 
        #   Action: Add Users to Groups
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        if ($ProcessUserMemberOf) {
            ol i "User Group Memberships ($NumberOfDomainUserMemberOf)" -sh
            
            # Both Role and Rights groups may have .member and .memberof 
            foreach ($DomainUser in $DomainUsers) {
                foreach ($DomainUserMemberOf in $DomainUser.MemberOf) {
                    
                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): $($DomainUser.name) member of: $DomainUserMemberOf"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
        
                    # Add $DomainUser to each MemberOf
                    $AddDryADGroupMemberParams = @{
                        Group  = $DomainUserMemberOf
                        Member = $DomainUser.name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $AddDryADGroupMemberParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $AddDryADGroupMemberParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Group Members", "Adding '$($DomainUser.name)' to '$DomainUserMemberOf'"
                    Add-DryADGroupMember @AddDryADGroupMemberParams
                    Remove-Variable -Name AddDryADGroupMemberParams -ErrorAction Ignore
                }
            }
        
        
            $DebugCounter += $NumberOfDomainUserMemberOf
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   ACTIVE DIRECTORY RIGHTS 
        #   Action: Delegate Rights in AD
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
        if ($ProcessRights) {
            ol i "Rights ($NumberOfDomainRights)" -sh

            # Domain Rights
            foreach ($DomainRightsGroup in $DomainRightsGroups) {
                foreach ($DomainRight in $DomainRightsGroup.Rights) {
                    ol v "Setting rights for group '$($DomainRightsGroup.groupname)'"
                    
                    # create hash from properties of the object 
                    Remove-Variable -Name SetDryADAccessRuleParams -ErrorAction Ignore
                    $SetDryADAccessRuleParams = @{}
                    
                    # Add all properties to the rights hash
                    $DomainRight.PSObject.Properties | foreach-Object {
                        $SetDryADAccessRuleParams.Add($_.Name, $_.Value)
                    }

                    # Add the groupname as 'Group' - the owner of the right
                    $SetDryADAccessRuleParams.Add('Group', $DomainRightsGroup.groupname)

                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryADAccessRuleParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryADAccessRuleParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }

                    # Debug logging
                    ol d -hash $SetDryADAccessRuleParams

                    # increment the element counter and update progress
                    $ElementsCounter++
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Domain Right: $($DomainRight.Path)"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                    }
                    Write-Progress @WriteProgressParameters
                    
                    # Set the right
                    ol i "Rights", "Group '$($DomainRightsGroup.groupname)'"
                    ol i "Rights", "Target '$($DomainRight.Path)'"
                    if ((Set-DryADAccessRule @SetDryADAccessRuleParams) -eq $true) {
                        ol i "Rights (domain '$DomainFQDN')", ''
                    } 
                    else {
                        ol e @("Rights", "Group '$($DomainRightsGroup.groupname)', Target '$($DomainRight.Path)'")
                        throw "Failed: domain '$DomainFQDN': Group '$($DomainRightsGroup.groupname)', Target '$($DomainRight.Path)'"
                    }

                    # Clean up
                    Remove-Variable -Name SetDryADAccessRuleParams, WriteProgressParameters -ErrorAction Ignore   
                }
            }

            $DebugCounter += $NumberOfDomainRights
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        }

        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICIES 
        #   Action: Define paths, copy helper modules and GPOs to remote target if
        #   ExecutionType 'Remote'
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessGPOImports) {
            switch ($ExecutionType) {
                'Remote' {
                    [string]$RemoteRootPath = "C:\DryDeploy\"
                    [string]$RemoteModulesPath = Join-Path -Path $RemoteRootPath -ChildPath 'modules'
                    [string]$GPOsPath = Join-Path -Path $RemoteRootPath -ChildPath 'gpo_imports'

                    # Only invoke if json-gpos in configuration
                    if ($RequiresGPOHelper) {
                        ol i "GPO Imports - Copying helper module to remote target" -sh
                        # Copies the dry.ad.gpohelper module to the remote target
                        $DryADGPOHelpersPath = Join-Path -Path (Split-Path -Path ((Get-Module -Name dry.module.ad).Path)) -ChildPath 'helpers\dry.ad.gpohelper' 
                        Copy-DryADFilesToRemoteTarget -PSSession $PSSession -TargetPath $RemoteModulesPath -SourcePath $DryADGPOHelpersPath | Out-Null
                        # Copies the GPRegistryPolicyParser module to the remote target
                        $DryADGPRegistryPolicyParserPath = Join-Path -Path (Split-Path -Path ((Get-Module -Name dry.module.ad).Path)) -ChildPath 'helpers\GPRegistryPolicyParser' 
                        Copy-DryADFilesToRemoteTarget -PSSession $PSSession -TargetPath $RemoteModulesPath -SourcePath $DryADGPRegistryPolicyParserPath | Out-Null
                        #Copy-DryADModulesToRemoteTarget -PSSession $PSSession -RemoteRootPath $RemoteRootPath -Modules @("GPRegistryPolicyParser") | Out-Null
                    }

                    Add-DryADPSModulesPath -PSSession $PSSession -Path $RemoteModulesPath -Modules @('dry.ad.gpohelper','GPRegistryPolicyParser') | Out-Null

                    ol i "GPO Imports - Copying GPOs to remote target" -sh
                    Copy-DryADFilesToRemoteTarget -PSSession $PSSession -TargetPath $RemoteRootPath -SourcePath $SourceGPOsPath | Out-Null
                }
                'Local' {
                    [string]$GPOsPath = $SourceGPOsPath
                }
            }  

            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            # 
            #   GROUP POLICIES 
            #   Action: Import
            #
            # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

            ol i "GPO Imports ($($DomainGPOImports.count))" -sh
            foreach ($GPO in $DomainGPOImports) {
                # Ensure TargetName exists, and is converted to the desired case
                if ($null -eq $GPO.TargetName) { 
                    $GPO | Add-Member -MemberType NoteProperty -Name 'TargetName' -Value $(ConvertTo-DryADCase -Name $GPO.Name -Case $GPOcase)
                }
                else {
                    $GPO.TargetName = ConvertTo-DryADCase -Name $GPO.TargetName -Case $GPOcase
                }

                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Importing GPO '$($GPO.TargetName)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                
                $ImportDryADGPOParams = @{
                    GPO             = $GPO 
                    GPOsPath        = $GPOsPath 
                    ReplacementHash = $ReplacementHash
                }

                switch ($ExecutionType) {
                    'Local' {
                        $ImportDryADGPOParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $ImportDryADGPOParams += @{
                            PSSession = $PSSession
                        }
                    }
                }
                ol i "GPO Import", "Importing '$($GPO.Name)'"
                Import-DryADGPO @ImportDryADGPOParams      
            }

            $DebugCounter += $NumberOfGPOImports
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }

        } # if ($ProcessGPO)


        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   GROUP POLICIES 
        #   Action: Links
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessGPOLinks) {
            ol i "GPO Links ($($DomainGPOLinks.count))" -sh

            foreach ($DomainGPOLink in $DomainGPOLinks | Where-Object { $_.defined_in -eq 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($DomainGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                 
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $DomainGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }

                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($DomainGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs to", "(Domain Root)"
                } 
                else {
                    ol i "Link GPOs to", "$($DomainGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

            foreach ($DomainGPOLink in $DomainGPOLinks | Where-Object { $_.defined_in -ne 'OS' }) {
                # increment the element counter and update progress
                $ElementsCounter++
                $WriteProgressParameters = @{
                    Activity        = 'Configuring Active Directory'
                    Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking GPOs to '$($DomainGPOLink.Path)'"
                    PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )   
                }
                Write-Progress @WriteProgressParameters
                 
                $SetDryGPLinkParams = @{
                    GPOLinkObject = $DomainGPOLink
                    DomainDN      = $DomainDN
                    DomainFQDN    = $DomainFQDN
                }
                switch ($ExecutionType) {
                    'Local' {
                        $SetDryGPLinkParams += @{
                            DomainController = $DomainController
                        }
                    }
                    'Remote' {
                        $SetDryGPLinkParams += @{
                            PSSession = $PSSession
                        }
                    }
                }

                if (($DomainGPOLink.Path).Trim() -eq '') {
                    ol i "Link GPOs to", "(Domain Root)"
                } 
                else {
                    ol i "Link GPOs to", "$($DomainGPOLink.Path)"
                }
                Set-DryADGPLink @SetDryGPLinkParams 
            }

            $DebugCounter += $NumberOfGPOLinks
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } # if ($ProcessGPOLinks)
        
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
        # 
        #   Wmi Filter Links 
        #   Action: Link to GPOs
        #
        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

        if ($ProcessWMIFilterLinks) {

            ol i "WMIFilterLinks ($DomainWmiFilterLinksCount)" -sh
            foreach ($GPOWMIFilter in $DomainWMIFilters) {
                foreach ($GPOWMIFilterLink in $GPOWMIFilter.links) {
                    # Progress
                    $ElementsCounter++  
                    $WriteProgressParameters = @{
                        Activity        = 'Configuring Active Directory'
                        Status          = "Item ($ElementsCounter / $NumberOfElementsToProcess): Linking WMIFilter '$($GPOWMIFilter.Name)'"
                        PercentComplete = (($ElementsCounter / $NumberOfElementsToProcess) * 100 )
                    }
                    Write-Progress @WriteProgressParameters
                
                    $SetDryWmiFilterLinkParams = @{
                        GPOName       = $GPOWMIFilterLink
                        WMIFilterName = $GPOWMIFilter.Name
                    }
                    switch ($ExecutionType) {
                        'Local' {
                            $SetDryWmiFilterLinkParams += @{
                                DomainController = $DomainController
                            }
                        }
                        'Remote' {
                            $SetDryWmiFilterLinkParams += @{
                                PSSession = $PSSession
                            }
                        }
                    }
                    ol i "Linking WMI Filter (domain '$DomainFQDN')", "$($GPOWMIFilter.Name)"
                    Set-DryADWmiFilterLink @SetDryWmiFilterLinkParams
                }
            }

            $DebugCounter += $NumberOfWMIFilterLinks
            if ($ElementsCounter -ne $DebugCounter) {
                throw "Elementscounter is $ElementsCounter, but was supposed to be $DebugCounter"
            }
        } 
        ol i "Import-DryADConfiguration ran successfully" -sh
    }
    catch {
        $PSCmdLet.ThrowTerminatingError($_)
    }
    finally {
        Write-Progress -Completed -Activity "Configuring AD objects"
    }
}